![image](https://github.com/user-attachments/assets/cafa4a85-a46d-4732-9dd1-16ae63c4e89e)

![image](https://github.com/user-attachments/assets/a2d2ca66-1f84-4454-bffa-a6e1bde516d4)


```markdown
##Встановлення та запуск

1. **Клонування репозиторію**  
   ```bash
   git clone https://github.com/xaxinotf/Test_DM_var-5_Cheban_Bogdan.git
   cd Test_DM_var-5_Cheban_Bogdan
   ```

2. **Створення й активація віртуального середовища**  
   _(приклад для PowerShell на Windows 10, Python 3.10)_  
   ```powershell
   python -m venv .venv
   .\.venv\Scripts\Activate.ps1
   ```

3. **Встановлення залежностей**  
   Створіть файл `requirements.txt` поруч із кодом із таким вмістом:
   ```
   pandas
   numpy
   dash
   plotly
   ```
   Потім:
   ```bash
   pip install -r requirements.txt
   ```

4. **Підготовка даних**  
   Переконайтеся, що файл `synthetic_customers.csv` лежить у корені репозиторію і містить ваші дані в такому форматі:
   ```
   age,income,loyalty_score
   23,20000,70
   45,50000,30
   … тощо …
   ```

5. **Запуск застосунку**  
   ```bash
   python Data_Mining_var5.py
   ```  
   Відкрийте у браузері http://127.0.0.1:8050

---

## Як працює код

1. **Реалізація K‑Means++**  
   - Перший центр вибираю випадково.  
   - Кожний наступний — з імовірністю, пропорційною квадрату відстані до вже обраних центрів.  
   - Це покращує стартове розташування й пришвидшує збіжність.

2. **Основний цикл K‑Means**  
   - Призначаю кожну точку до найближчого центроїда (найменша сума квадратів відстаней).  
   - Оновлюю центроїди як середнє значення точок у їхніх кластерах.  
   - Перериваюся, коли центри перестають змінюватися.

3. **Метод Elbow**  
   - Розраховую SSE (сума квадратів відхилень) для k від 1 до 10.  
   - Знаходжу «лікоть» за другою похідною кривої SSE → оптимальне число кластерів.

4. **Dash‑інтерфейс**  
   - Малюю два графіки:  
     - **Elbow** (SSE vs k)  
     - **Scatter** (вікові пункти vs дохід, розмір кружечків = loyalty_score)  
   - Додаю слайдер для динамічного вибору k і callback, який оновлює кластеризацію «на льоту».  
   - Весь інтерфейс і підписи — українською, стилі через CSS у `app.index_string`.

---

## Як я виконав завдання

1. **Програмний компонент**  
   — Написав власну реалізацію алгоритму K‑Means із «розумним» стартом k‑means++.  
2. **Аналітичний компонент**  
   — Автоматизував підрахунок SSE, побудував Elbow‑графік і знайшов оптимальне k.  
3. **Візуалізація**  
   — Створив інтерактивний веб‑застосунок на Dash з приємним дизайном і можливістю експериментувати зі значенням к‑ластерів.  
4. **Документація**  
   — Описав інструкції й коментарі так, щоб було зрозуміло та коротко.
